'use strict';

const assert = require('assert');
const sinon = require('sinon');

const KeyGenerator = require('../src/key-generator');
const CoreKeyGenerator = require('../src/core-key-generator');

const DummyPublicKeyStore = require('./dummy-public-key-store');

const EXPIRY_CLOCK_SKEW = 5 * 60;
const TEST_SIGNING_KEY_USE = 60 * 60;
const TEST_TOKEN_LIFETIME = 5 * 60;

describe('KeyGenerator', () => {
	let clock, dummyPublicKeyStore;

	beforeEach(() => {
		clock = sinon.useFakeTimers();
		dummyPublicKeyStore = new DummyPublicKeyStore();
	});

	afterEach(() => {
		clock.restore();
		sinon.restore();
	});

	function createKeyGenerator(opts) {
		return new KeyGenerator(Object.assign({
			publicKeyStore: dummyPublicKeyStore,
			signingKeyType: 'EC',
			ec: {
				crv: 'P-256'
			},
			rsa: {
				signingKeySize: 2048
			}
		}, opts, Object.assign({
			keyUse: TEST_SIGNING_KEY_USE,
			token: TEST_TOKEN_LIFETIME
		}, opts && opts.lifetimes)));
	}

	describe('constructor(...)', () => {
		beforeEach(() => sinon.stub(KeyGenerator.prototype, '_rotate'));
		beforeEach(() => sinon.stub(KeyGenerator.prototype, '_ensureGenerated'));

		it('should throw if options is not an object', () => {
			for (const val of [undefined, 'hi!', function() {}, 1000]) {
				assert.throws(
					() => new KeyGenerator(val),
					TypeError,
					/opts.+Object/
				);
			}
		});

		it('should throw if lifetimes.keyUse is not an integer', () => {
			for (const val of ['3600', {}, function() {}, 3600.5]) {
				assert.throws(
					() => createKeyGenerator({ lifetimes: { keyUse: val } }),
					TypeError,
					/lifetimes.keyUse.+integer/
				);
			}
		});

		it('should throw if lifetimes.keyUse is negative', () => {
			assert.throws(
				() => createKeyGenerator({ lifetimes: { keyUse: -1 } }),
				Error,
				/lifetimes.keyUse/
			);
		});

		it('should throw if lifetimes.keyUse is zero', () => {
			assert.throws(
				() => createKeyGenerator({ lifetimes: { keyUse: 0 } }),
				Error,
				/lifetimes.keyUse/
			);
		});

		it('should throw is lifetimes.keyUse is too large', () => {
			assert.throws(
				() => createKeyGenerator({ lifetimes: { keyUse: 24 * 60 * 60 + 1 } }),
				Error,
				/lifetimes.keyUse/
			);
		});

		it('should throw if lifetimes.token is not an integer', () => {
			for (const val of ['3000', {}, function() {}, 3000.5]) {
				assert.throws(
					() => createKeyGenerator({ lifetimes: { token: val } }),
					TypeError,
					/lifetimes.token.+integer/
				);
			}
		});

		it('should throw if lifetimes.token is negative', () => {
			assert.throws(
				() => createKeyGenerator({ lifetimes: { token: -1 } }),
				Error,
				/lifetimes.token/
			);
		});

		it('should throw if lifetimes.token is zero', () => {
			assert.throws(
				() => createKeyGenerator({ lifetimes: { token: 0 } }),
				Error,
				/lifetimes.token/
			);
		});

		it('instantiates CoreKeyGenerator', () => {
			const generator = createKeyGenerator();
			assert(generator._core instanceof CoreKeyGenerator);
		});
	});

	describe('key generation', () => {
		beforeEach(() => sinon.stub(dummyPublicKeyStore, 'storePublicKey').resolves());

		describe('RSA', /* @this */ function() {
			this.timeout(5000);

			it('calls storePublicKey with public rsa jwk and proper expiry', async() => {
				const CURRENT_TIME_MS = 25000;
				clock.tick(CURRENT_TIME_MS);

				const keygen = createKeyGenerator({ signingKeyType: 'RSA' });
				assert.strictEqual(0, dummyPublicKeyStore.storePublicKey.callCount);

				await keygen._current;

				sinon.assert.calledWith(
					dummyPublicKeyStore.storePublicKey,
					sinon.match({
						kty: 'RSA',
						alg: 'RS256',
						exp: Math.round(CURRENT_TIME_MS / 1000)
							+ TEST_SIGNING_KEY_USE
							+ TEST_TOKEN_LIFETIME
							+ EXPIRY_CLOCK_SKEW
					})
				);
			});
		});

		describe('EC', () => {
			it('calls storePublicKey with public ec jwk and proper expiry', async() => {
				const CURRENT_TIME_MS = 25000;
				clock.tick(CURRENT_TIME_MS);

				const keygen = createKeyGenerator({ signingKeyType: 'EC' });
				assert.strictEqual(0, dummyPublicKeyStore.storePublicKey.callCount);

				await keygen._current;

				sinon.assert.calledWith(
					dummyPublicKeyStore.storePublicKey,
					sinon.match({
						kty: 'EC',
						alg: sinon.match(/^ES\d\d\d$/),
						exp: Math.round(CURRENT_TIME_MS / 1000)
							+ TEST_SIGNING_KEY_USE
							+ TEST_TOKEN_LIFETIME
							+ EXPIRY_CLOCK_SKEW
					})
				);
			});
		});

		describe('failure', () => {
			it('should emit the error, and retry', async() => {
				clock.restore();

				const failure = new Error('error that should be emitted');

				dummyPublicKeyStore
					.storePublicKey
					.onFirstCall().rejects(failure)
					.onSecondCall().resolves()
					.resolves();

				const keygen = createKeyGenerator({ signingKeyType: 'EC' });
				const emittedError = new Promise(resolve => {
					keygen.once('error', resolve);
				});

				assert.strictEqual(await emittedError, failure);

				await keygen.getCurrentPrivateKey();

				sinon.assert.calledTwice(dummyPublicKeyStore.storePublicKey);
			});
		});
	});

	describe('getCurrentPrivateKey(...)', () => {
		beforeEach(() => sinon.stub(dummyPublicKeyStore, 'storePublicKey').resolves());

		let keygen;
		beforeEach(() => keygen = createKeyGenerator());

		it('returns current key', () => {
			const CURRENT_TIME_MS = 25000;
			clock.tick(CURRENT_TIME_MS);

			keygen._current = Promise.resolve({
				key: 'cats',
				deadline: Math.round(CURRENT_TIME_MS / 1000) + 1
			});

			return keygen
				.getCurrentPrivateKey()
				.then(key => assert.strictEqual('cats', key));
		});
	});
});
