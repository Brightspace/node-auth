'use strict';

const { generateKeyPairSync } = require('crypto');

const
	BrightspaceAuthToken = require('brightspace-auth-token'),
	chai = require('chai'),
	chaiAsPromised = require('chai-as-promised'),
	expect = chai.expect,
	jwt = require('jsonwebtoken'),
	keyto = require('@trust/keyto'),
	sinon = require('sinon'),
	{ MockAgent, setGlobalDispatcher } = require('undici');

const ISSUER = 'http://auth-bar-baz.test.d2l/baz';

function interceptJwks(cb) {
	const mockAgent = new MockAgent({ connections: 1 });
	const mockClient = mockAgent.get('http://auth-bar-baz.test.d2l/');

	setGlobalDispatcher(mockClient);

	cb(mockClient.intercept({
		path: '/baz/.well-known/jwks',
		method: 'GET',
		headers: {
			'User-Agent': /^node-auth\/brightspace-auth-validation\/\d/,
		},
	}));
}

const AuthTokenValidator = require('../');

chai.use(chaiAsPromised);

describe('validations', function() {
	let
		clock,
		token,
		validator;

	const { publicKey, privateKey } = generateKeyPairSync('rsa', {
		modulusLength: 512,
		publicKeyEncoding: {
			type: 'spki',
			format: 'pem'
		},
		privateKeyEncoding: {
			type: 'pkcs8',
			format: 'pem'
		}
	});
	const jwk = Object.assign(keyto.from(publicKey, 'pem').toJwk('public'), {
		kid: 'foo-bar-baz',
		use: 'sig'
	});

	const maxClockSkew = 10;

	before(function(done) {
		clock = sinon.useFakeTimers({ shouldAdvanceTime: true });
		done();
	});

	beforeEach(function(done) {
		token = undefined;
		validator = new AuthTokenValidator({
			issuer: ISSUER,
			maxClockSkew,
		});
		done();
	});

	after(function(done) {
		clock.restore();
		done();
	});

	it('should throw "NoAuthorizationProvided" when there is no auth header', function() {
		return expect(validator.fromHeaders({}))
			.to.be.rejectedWith(AuthTokenValidator.errors.NoAuthorizationProvided);
	});

	it('should throw "NoAuthorizationProvided" when auth header is not a Bearer token', function() {
		return expect(validator.fromHeaders({ authorization: 'Basic foobarbaz' }))
			.to.be.rejectedWith(AuthTokenValidator.errors.NoAuthorizationProvided);
	});

	it('should throw "BadToken" when invalid token is sent', function() {
		return expect(validator.fromHeaders({ authorization: 'Bearer foobarbaz' }))
			.to.be.rejectedWith(AuthTokenValidator.errors.BadToken);
	});

	it('should throw "BadToken" when expired token is sent', function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: 'foo-bar-baz'
			},
			expiresIn: -1 * (maxClockSkew)
		});

		return expect(validator.fromHeaders({ authorization: `Bearer ${ token }` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.BadToken);
	});

	it('should throw "BadToken" when not-yet-valid token is sent (outside of skew)', function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: 'foo-bar-baz'
			},
			notBefore: maxClockSkew + 1
		});

		return expect(validator.fromHeaders({ authorization: `Bearer ${ token }` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.BadToken);
	});

	it('should throw "BadToken" for bad signature', async function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: 'foo-bar-baz'
			}
		});

		token += 'mess-up-the-signature';

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		await expect(validator.fromHeaders({ authorization: `Bearer ${token}` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.BadToken);
	});

	it('should throw "PublicKeyNotFound" when no key with matching "kid" is found on auth server', async function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: 'errmegerd'
			}
		});

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		await expect(validator.fromHeaders({ authorization: `Bearer ${ token }` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.PublicKeyNotFound);
	});

	it('should throw "PublicKeyNotFound" when key with matching "kid" was found, but had a past exp', async function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: jwk.kid
			}
		});

		interceptJwks(x => x.reply(200, {
			keys: [Object.assign({}, jwk, { exp: Math.round(Date.now() / 1000) - maxClockSkew })]
		}));

		await expect(validator.fromHeaders({ authorization: `Bearer ${token}` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.PublicKeyNotFound);
	});

	it('should throw "PublicKeyLookupFailed" when there is an error requesting the jwks', async function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: 'errmegerd'
			}
		});

		interceptJwks(x => x.reply(404));

		await expect(validator.fromHeaders({ authorization: `Bearer ${ token }` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.PublicKeyLookupFailed);
	});

	it('should NOT throw "PublicKeyLookupFailed" when there WAS error requesting the jwks', async function() {
		token = jwt.sign({}, privateKey, {
			algorithm: 'RS256',
			header: {
				kid: 'errmegerd'
			}
		});

		interceptJwks(x => x.reply(404));

		await expect(validator.fromHeaders({ authorization: `Bearer ${ token }` }))
			.to.be.rejectedWith(AuthTokenValidator.errors.PublicKeyLookupFailed);

		const
			payload = {
				key: 'val'
			},
			signature = jwt.sign(payload, privateKey, {
				algorithm: 'RS256',
				header: {
					kid: 'foo-bar-baz'
				}
			});

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		token = await validator.fromHeaders({
			authorization: `Bearer ${ signature }`
		});
		expect(token).to.be.instanceof(BrightspaceAuthToken);
		expect(token.source).to.equal(signature);
	});

	it('should return BrightspaceAuthToken when matching "kid" is found on auth server and signature is valid', async function() {
		const
			payload = {
				key: 'val'
			},
			signature = jwt.sign(payload, privateKey, {
				algorithm: 'RS256',
				header: {
					kid: 'foo-bar-baz'
				}
			});

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		token = await validator.fromHeaders({
			authorization: `Bearer ${ signature }`
		});
		expect(token).to.be.instanceof(BrightspaceAuthToken);
		expect(token.source).to.equal(signature);
	});

	it('should return BrightspaceAuthToken when matching "kid" is found on auth server, signature is valid, and expiry is within clock skew', async function() {
		const
			payload = {
				key: 'val'
			},
			signature = jwt.sign(payload, privateKey, {
				algorithm: 'RS256',
				header: {
					kid: 'foo-bar-baz'
				},
				expiresIn: -1 * maxClockSkew + 1
			});

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		token = await validator.fromHeaders({
			authorization: `Bearer ${ signature }`
		});
		expect(token).to.be.instanceof(BrightspaceAuthToken);
		expect(token.source).to.equal(signature);
	});

	it('should return BrightspaceAuthToken when matching "kid" is found on auth server, signature is valid and nbf is within clock skew', async function() {
		const
			payload = {
				key: 'val'
			},
			signature = jwt.sign(payload, privateKey, {
				algorithm: 'RS256',
				header: {
					kid: 'foo-bar-baz'
				},
				notBefore: maxClockSkew
			});

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		token = await validator.fromHeaders({
			authorization: `Bearer ${ signature }`
		});
		expect(token).to.be.instanceof(BrightspaceAuthToken);
		expect(token.source).to.equal(signature);
	});

	it('should return BrightspaceAuthToken even when more than one space separates "Bearer" and the signature', async function() {
		const
			payload = {
				key: 'val'
			},
			signature = jwt.sign(payload, privateKey, {
				algorithm: 'RS256',
				header: {
					kid: 'foo-bar-baz'
				},
				expiresIn: -1 * maxClockSkew + 1
			});

		interceptJwks(x => x.reply(200, {
			keys: [jwk]
		}));

		token = await validator.fromHeaders({
			authorization: `Bearer     ${ signature }`
		});
		expect(token).to.be.instanceof(BrightspaceAuthToken);
		expect(token.source).to.equal(signature);
	});

	describe('validateConfiguration', function() {
		it('should return true when public keys can be updated', async function() {
			interceptJwks(x => x.reply(200, {
				keys: [jwk]
			}));

			const auth = new AuthTokenValidator({
				issuer: ISSUER
			});

			await expect(auth.validateConfiguration()).to.eventually.be.true;
		});

		it('should return an error when public key lookup fails', function() {
			interceptJwks(x => x.reply(404));

			const auth = new AuthTokenValidator({
				issuer: ISSUER
			});

			return expect(auth.validateConfiguration()).to.be.rejectedWith(Error);
		});
	});
});
