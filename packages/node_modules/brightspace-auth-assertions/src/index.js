'use strict';

const AuthToken = require('brightspace-auth-token');

const errors = require('./errors');

class AssertionCompiler {
	constructor() {
		this._assertions = [];
	}

	scope(broad, narrow, permission) {
		const assertion = new ScopeAssertion(this, broad, narrow, permission);
		return assertion;
	}

	context(context) {
		const assertion = new ContextAssertion(this, context);
		return assertion;
	}

	impersonation() {
		const assertion = new ImpersonationAssertion(this);
		return assertion;
	}

	compile() {
		const assertions = this._assertions.slice();
		return function compiledAassertion(token) {
			for (const assertion of assertions) {
				assertion.assert(token);
			}
		};
	}

}

class AuthAssertion {
	constructor(compiler) {
		if (!(compiler instanceof AssertionCompiler)) {
			throw new Error();
		}

		this._compiler = compiler;
		this._required = false;
		this._rejected = false;
	}

	require() {
		this._required = true;

		if ('function' === typeof this._require) {
			this._require();
		}

		return this._inject();
	}

	reject() {
		this._rejected = true;

		if ('function' === typeof this._reject) {
			this._reject();
		}

		return this._inject();
	}

	assert(token) {
		if ('function' === typeof this._assert) {
			this._assert(token);
		}
	}

	_inject() {
		this._compiler._assertions.push(this);

		return this._compiler;
	}
}

class ScopeAssertion extends AuthAssertion {
	constructor(compiler, broad, narrow, permission) {
		super(compiler);

		this.broad = broad;
		this.narrow = narrow;
		this.permission = permission;
	}

	_assert(token) {
		const matched = token.hasScope(this.broad, this.narrow, this.permission);

		if (!matched) {
			throw new errors.InsufficientScope(this.broad, this.narrow, this.permission);
		}
	}

	_reject() {
		throw new Error('Rejecting a scope makes no sense');
	}
}

class ContextAssertion extends AuthAssertion {
	constructor(compiler, context) {
		super(compiler);

		this.context = context;
	}

	_assert(token) {
		let matched = false;

		switch (this.context) {
			case AuthToken.contexts.User: {
				matched = token.isUserContext();
				break;
			}
			case AuthToken.contexts.Tenant: {
				matched = token.isTenantContext();
				break;
			}
			case AuthToken.contexts.Global: {
				matched = token.isGlobalContext();
				break;
			}
		}

		if ((this._required && !matched) || (this._rejected && matched)) {
			throw new errors.InvalidContext();
		}
	}
}

class ImpersonationAssertion extends AuthAssertion {
	constructor(compiler) {
		super(compiler);
	}

	_require() {
		new ContextAssertion(this._compiler, AuthToken.contexts.User).require();
	}

	_assert(token) {
		if (this._required) {
			if (!token.isImpersonating()) {
				throw new errors.ImpersonationRequired();
			}
		} else if (/* this._rejected && */token.isImpersonating()) {
			throw new errors.ImpersonationNotAllowed(token.user, token.actualUser);
		}
	}
}

module.exports = AssertionCompiler;
module.exports.contexts = AuthToken.contexts;
module.exports.errors = errors;
