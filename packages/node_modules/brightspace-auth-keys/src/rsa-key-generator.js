'use strict';

const { generateKeyPair, createPublicKey } = require('crypto');

const pem2jwk = require('pem2jwk');

const DEFAULT_SIZE = 2048;
const MINIMUM_SIZE = 2048;

const SUPPORTS_KEY_OBJECTS = typeof createPublicKey === 'function';
const PUBLIC_EXPORT_OPTIONS = {
	type: 'spki',
	format: 'pem'
};
const PRIVATE_EXPORT_OPTIONS = SUPPORTS_KEY_OBJECTS
	? null
	: {
		type: 'pkcs8',
		format: 'pem'
	};

function keygen(opts, kid) {
	return new Promise((resolve, reject) => {
		generateKeyPair('rsa', {
			modulusLength: opts.size,
			publicKeyEncoding: PUBLIC_EXPORT_OPTIONS,
			privateKeyEncoding: PRIVATE_EXPORT_OPTIONS
		}, (err, publicKey, privateKey) => {
			if (err) {
				return reject(err);
			}

			resolve([
				pem2jwk(publicKey),
				privateKey
			]);
		});
	})
		.then(res => {
			return {
				jwk: {
					kid,
					kty: res[0].kty,
					n: res[0].n,
					e: res[0].e,
					alg: 'RS256',
					use: 'sig'
				},
				signingKey: {
					kid,
					key: res[1],
					alg: 'RS256'
				}
			};
		});
}

module.exports = keygen;
module.exports.normalize = function normalize(opts) {
	if (opts && typeof opts.signingKeySize !== 'undefined') {
		const size = opts.signingKeySize;

		if (typeof size !== 'number') {
			throw new TypeError(`"opts.rsa.signingKeySize" should be a Number. Got "${typeof size}".`);
		}

		if (size !== Math.round(size)) {
			throw new TypeError(`"opts.rsa.signingKeySize" should be an integer. Got "${size}".`);
		}

		if (size < MINIMUM_SIZE) {
			throw new Error(`"opts.rsa.signingKeySize" must be atleast ${MINIMUM_SIZE}. Got "${size}".`);
		}

		return { size };
	}

	return { size: DEFAULT_SIZE };
};
