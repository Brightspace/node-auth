'use strict';

const assert = require('assert');
const sinon = require('sinon');

const CoreKeyGenerator = require('../src/core-key-generator');
const ecKeygen = require('../src/ec-key-generator');
const rsaKeygen = require('../src/rsa-key-generator');

const DummyPublicKeyStore = require('./dummy-public-key-store');

const DEFAULT_SIGNING_KEY_AGE = 60 * 60;
const EXPIRY_CLOCK_SKEW = 5 * 60;

const
	dummyPublicKeyStore = new DummyPublicKeyStore();

describe('CoreKeyGenerator', () => {
	let clock;

	beforeEach(() => {
		clock = sinon.useFakeTimers();
	});

	afterEach(() => {
		clock.restore();
		sinon.restore();
	});

	function createKeyGenerator(opts) {
		return new CoreKeyGenerator(Object.assign({
			publicKeyStore: dummyPublicKeyStore,
			signingKeyType: 'EC',
			ec: {
				crv: 'P-256'
			},
			rsa: {
				signingKeySize: 2048
			}
		}, opts));
	}

	describe('constructor(...)', () => {
		beforeEach(() => sinon.stub(CoreKeyGenerator.prototype, 'generateNewKey'));

		it('should throw if options is not an object', () => {
			for (const val of [undefined, 'hi!', function() {}, 1000]) {
				assert.throws(
					() => new CoreKeyGenerator(val),
					TypeError,
					/opts.+Object/
				);
			}
		});

		it('should throw if publicKeyStore is not an AbstractPublicKeyStore', () => {
			assert.throws(
				() => createKeyGenerator({ publicKeyStore: {} }),
				TypeError,
				/publicKeyStore.+AbstractPublicKeyStore/
			);
		});

		it('should throw if signingKeyType is invalid', () => {
			for (const alg of ['dsa', 'rsa', 'rSA', 'eCDSA', 'foo', 1]) {
				assert.throws(
					() => createKeyGenerator({ signingKeyType: alg }),
					Error,
					/signingKeyType/
				);
			}
		});

		describe('RSA', /* @this */ function() {
			this.timeout(5000);

			it('should check options with rsaKeygen.normalize and succeed', () => {
				sinon.spy(rsaKeygen, 'normalize');
				assert.strictEqual(0, rsaKeygen.normalize.callCount);
				createKeyGenerator({ signingKeyType: 'RSA', rsa: { singingKeySize: 2048 } });
				assert.strictEqual(1, rsaKeygen.normalize.callCount);
			});
		});

		describe('EC', () => {
			it('should check options with ecKeygen.normalize and succeed', () => {
				sinon.spy(ecKeygen, 'normalize');
				assert.strictEqual(0, ecKeygen.normalize.callCount);
				createKeyGenerator({ signingKeyType: 'EC', ec: { crv: 'P-256' } });
				assert.strictEqual(1, ecKeygen.normalize.callCount);
			});
		});

		it('should not call generateNewKey', () => {
			createKeyGenerator();
			assert.strictEqual(0, CoreKeyGenerator.prototype.generateNewKey.callCount);
		});
	});

	describe('generateNewKey(...)', () => {
		beforeEach(() => sinon.stub(dummyPublicKeyStore, 'storePublicKey').resolves());

		describe('RSA', /* @this */ function() {
			this.timeout(5000);

			it('calls storePublicKey with public rsa jwk and default expiry', async() => {
				const CURRENT_TIME_MS = 25000;
				clock.tick(CURRENT_TIME_MS);

				const keygen = createKeyGenerator({ signingKeyType: 'RSA' });

				await keygen.generateNewKey();

				sinon.assert.calledWith(
					dummyPublicKeyStore.storePublicKey,
					sinon.match({
						kty: 'RSA',
						alg: 'RS256',
						exp: Math.round(CURRENT_TIME_MS / 1000)
							+ DEFAULT_SIGNING_KEY_AGE
							+ EXPIRY_CLOCK_SKEW
					})
				);
			});

			it('calls storePublicKey with public rsa jwk and passed in expiry', async() => {
				const keygen = createKeyGenerator({ signingKeyType: 'RSA' });

				await keygen.generateNewKey(1234);

				sinon.assert.calledWith(
					dummyPublicKeyStore.storePublicKey,
					sinon.match({
						kty: 'RSA',
						alg: 'RS256',
						exp: 1234 + EXPIRY_CLOCK_SKEW
					})
				);
			});
		});

		describe('EC', () => {
			it('calls storePublicKey with public ec jwk and default expiry', async() => {
				const CURRENT_TIME_MS = 25000;
				clock.tick(CURRENT_TIME_MS);

				const keygen = createKeyGenerator({ signingKeyType: 'EC' });

				await keygen.generateNewKey();

				sinon.assert.calledWith(
					dummyPublicKeyStore.storePublicKey,
					sinon.match({
						kty: 'EC',
						alg: sinon.match(/^ES\d\d\d$/),
						exp: Math.round(CURRENT_TIME_MS / 1000)
							+ DEFAULT_SIGNING_KEY_AGE
							+ EXPIRY_CLOCK_SKEW
					})
				);
			});

			it('calls storePublicKey with public ec jwk and passed in expiry', async() => {
				const keygen = createKeyGenerator({ signingKeyType: 'EC' });

				await keygen.generateNewKey(1234);

				sinon.assert.calledWith(
					dummyPublicKeyStore.storePublicKey,
					sinon.match({
						kty: 'EC',
						alg: sinon.match(/^ES\d\d\d$/),
						exp: 1234 + EXPIRY_CLOCK_SKEW
					})
				);
			});
		});
	});
});
