'use strict';

const errors = require('./errors');

class AssertionCompiler {
	constructor() {
		this._assertions = [];
	}

	scope(broad, narrow, permission) {
		const assertion = new ScopeAssertion(this, broad, narrow, permission);
		return assertion;
	}

	context(context) {
		const assertion = new ContextAssertion(this, context);
		return assertion;
	}

	impersonation() {
		const assertion = new ImpersonationAssertion(this);
		return assertion;
	}

	compile() {
		const assertions = this._assertions.slice();
		return function compiledAassertion(token) {
			for (const assertion of assertions) {
				assertion.assert(token);
			}
		};
	}

}

class AuthAssertion {
	constructor(compiler) {
		if (!(compiler instanceof AssertionCompiler)) {
			throw new Error();
		}

		this._compiler = compiler;
		this._required = false;
		this._rejected = false;
	}

	require() {
		this._required = true;

		if ('function' === typeof this._require) {
			this._require();
		}

		return this._inject();
	}

	reject() {
		this._rejected = true;

		if ('function' === typeof this._reject) {
			this._reject();
		}

		return this._inject();
	}

	assert(token) {
		if ('function' === typeof this._assert) {
			this._assert(token);
		}
	}

	_inject() {
		this._compiler._assertions.push(this);

		return this._compiler;
	}
}

class ScopeAssertion extends AuthAssertion {
	constructor(compiler, broad, narrow, permission) {
		super(compiler);

		this.broad = broad;
		this.narrow = narrow;
		this.permission = permission;
	}

	_assert(token) {
		const matched = token.hasScope(this.broad, this.narrow, this.permission);

		if (!matched) {
			throw new errors.InsufficientScope(this.broad, this.narrow, this.permission);
		}
	}

	_reject() {
		throw new Error('Rejecting a scope makes no sense');
	}
}

class ContextAssertion extends AuthAssertion {
	constructor(compiler, context) {
		super(compiler);

		switch (context) {
			case 'user':
			case 'tenant':
			case 'global':
				this.context = context;
				break;
			default:
				throw new TypeError(`Expected "context" to be one of "user", "tenant", "global". Saw "${context}" (${typeof context}).`);
		}
	}

	_assert(token) {
		const matched = this.context === token.context;

		if (this._required) {
			if (matched) {
				return;
			}

			throw new errors.InvalidContext(this._required, this.context, token.context);
		}

		if (matched) {
			throw new errors.InvalidContext(this._required, this.context, token.context);
		}
	}
}

class ImpersonationAssertion extends AuthAssertion {
	constructor(compiler) {
		super(compiler);
	}

	_require() {
		this._compiler.context('user').require();
	}

	_assert(token) {
		if (this._required) {
			if (!token.isImpersonating()) {
				throw new errors.ImpersonationRequired();
			}
		} else if (/* this._rejected && */token.isImpersonating()) {
			throw new errors.ImpersonationNotAllowed(token.user, token.actualUser);
		}
	}
}

module.exports = AssertionCompiler;
module.exports.errors = errors;
