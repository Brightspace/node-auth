'use strict';

const qs = require('querystring');

const jws = require('jws');
const request = require('superagent');
const { v4: uuid } = require('uuid');

const AbstractProvisioningCache = require('./abstract-provisioning-cache');
const clock = require('./clock');

const ASSERTION_AUDIENCE = 'https://api.brightspace.com/auth/token';
const ASSERTION_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:jwt-bearer';
const ASSERTION_LIFETIME_SECONDS = 60;
const DEFAULT_REMOTE_ISSUER = 'https://auth.brightspace.com/core';
const TOKEN_PATH = '/connect/token';
const SUPPORTED_ALGS = ['ES256', 'ES384', 'ES512', 'RS256'/*, 'RS384', 'RS512'*/]; // D2L.Security.OAuth2 assumes RS256

class AuthTokenProvisioner {
	constructor(opts) {
		opts = opts || {};

		if ('string' !== typeof opts.issuer || 0 === opts.issuer.length) {
			throw new Error('"opts.issuer" must be a valid string');
		}

		if ('function' !== typeof opts.keyLookup) {
			throw new Error('"opts.keyLookup" must be a function which returns a Promise to a signing key');
		}

		this._cache = opts.cache || new AbstractProvisioningCache();

		if (!(this._cache instanceof AbstractProvisioningCache)) {
			throw new Error('"opts.cache" must be an instance of AbstractProvisioningCache if provided');
		}

		const remoteIssuer = 'string' === typeof opts.remoteIssuer
			? opts.remoteIssuer.replace(/\/+$/g, '')
			: DEFAULT_REMOTE_ISSUER;

		this._clock = clock;
		this._issuer = opts.issuer;
		this._latestKey = opts.keyLookup;
		this._tokenEndpoint = remoteIssuer + TOKEN_PATH;
	}

	async provisionToken(opts) {
		opts = opts || {};

		if (!Array.isArray(opts.scopes)) {
			throw new Error('"opts.scopes" must be an array of strings');
		}

		const scope = opts.scopes.join(' ');

		const claims = {};
		if (opts.user) {
			if (!opts.tenant) {
				throw new Error('"opts.user" depends on "opts.tenant"');
			}

			claims.sub = opts.user;
		}
		if (opts.tenant) {
			claims.tenantid = opts.tenant;
		}
		if (opts.impersonator) {
			if (!claims.sub) {
				throw new Error('"opts.impersonator" depends on "opts.user"');
			}

			claims.actualsub = opts.impersonator;
		}

		if (opts.fsid) {
			claims.fsid = opts.fsid;
		}

		try {
			return await this._cache.get(claims, scope);
		} catch (ignore) { /* ignore */ }

		const assertion = await this._buildAssertion(claims);
		const token = await this._makeAssertion(assertion, scope);

		try {
			await this._cache.set(claims, scope, token);
		} catch (ignore) { /* ignore */ }

		return token;
	}

	async _buildAssertion(payload) {
		const signingKey = await this._latestKey();

		if (null === signingKey
			|| 'object' !== typeof signingKey
			|| 'string' !== typeof signingKey.kid
			|| !SUPPORTED_ALGS.includes(signingKey.alg)
			|| 'object' !== typeof signingKey.key
		) {
			throw new Error('received invalid signing key from "keyLookup"');
		}

		payload = Object.assign({}, payload);

		payload.aud = ASSERTION_AUDIENCE;
		payload.iss = this._issuer;
		payload.iat = payload.nbf = this._clock();
		payload.exp = payload.iat + ASSERTION_LIFETIME_SECONDS;

		const assertion = jws.sign({
			header: {
				alg: signingKey.alg,
				kid: signingKey.kid,
				typ: 'JWT',
				jti: uuid()
			},
			payload: JSON.stringify(payload),
			secret: signingKey.key,
			encoding: 'utf8'
		});

		return assertion;
	}

	_makeAssertion(assertion, scope) {
		const self = this;

		const body = qs.stringify({
			assertion: assertion,
			grant_type: ASSERTION_GRANT_TYPE,
			scope: scope
		});

		return new Promise(function(resolve, reject) {
			request
				.post(self._tokenEndpoint)
				.type('application/x-www-form-urlencoded')
				.send(body)
				.end(function(err, res) {
					if (err) {
						reject(err);
						return;
					}

					resolve(res.body.access_token);
				});
		});
	}

}

module.exports = AuthTokenProvisioner;
module.exports.AbstractProvisioningCache = AbstractProvisioningCache;
