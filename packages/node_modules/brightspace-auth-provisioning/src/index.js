'use strict';

const { randomUUID: uuid } = require('crypto');

const jose = require('jose/jwt/sign');

const AbstractProvisioningCache = require('./abstract-provisioning-cache');
const clock = require('./clock');

const ASSERTION_AUDIENCE = 'https://api.brightspace.com/auth/token';
const ASSERTION_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:jwt-bearer';
const ASSERTION_LIFETIME_SECONDS = 60;
const DEFAULT_REMOTE_ISSUER = 'https://auth.brightspace.com/core';
const TOKEN_PATH = '/connect/token';
const SUPPORTED_ALGS = ['ES256', 'ES384', 'ES512', 'RS256'/*, 'RS384', 'RS512'*/]; // D2L.Security.OAuth2 assumes RS256

class AuthTokenProvisioner {
	constructor(opts) {
		opts = opts || {};

		if ('string' !== typeof opts.issuer || 0 === opts.issuer.length) {
			throw new Error('"opts.issuer" must be a valid string');
		}

		if ('function' !== typeof opts.keyLookup) {
			throw new Error('"opts.keyLookup" must be a function which returns a Promise to a signing key');
		}

		this._cache = opts.cache || new AbstractProvisioningCache();

		if (!(this._cache instanceof AbstractProvisioningCache)) {
			throw new Error('"opts.cache" must be an instance of AbstractProvisioningCache if provided');
		}

		const remoteIssuer = 'string' === typeof opts.remoteIssuer
			? opts.remoteIssuer.replace(/\/+$/g, '')
			: DEFAULT_REMOTE_ISSUER;

		this._clock = clock;
		this._issuer = opts.issuer;
		this._latestKey = opts.keyLookup;
		this._tokenEndpoint = remoteIssuer + TOKEN_PATH;
	}

	async provisionToken(opts) {
		opts = opts || {};

		if (!Array.isArray(opts.scopes)) {
			throw new Error('"opts.scopes" must be an array of strings');
		}

		const scope = opts.scopes.join(' ');

		const claims = {};
		if (opts.user) {
			if (!opts.tenant) {
				throw new Error('"opts.user" depends on "opts.tenant"');
			}

			claims.sub = opts.user;
		}
		if (opts.tenant) {
			claims.tenantid = opts.tenant;
		}
		if (opts.impersonator) {
			if (!claims.sub) {
				throw new Error('"opts.impersonator" depends on "opts.user"');
			}

			claims.actualsub = opts.impersonator;
		}

		if (opts.fsid) {
			claims.fsid = opts.fsid;
		}

		try {
			return await this._cache.get(claims, scope);
		} catch (ignore) { /* ignore */ }

		const assertion = await this._buildAssertion(claims);
		const token = await this._makeAssertion(assertion, scope);

		try {
			await this._cache.set(claims, scope, token);
		} catch (ignore) { /* ignore */ }

		return token;
	}

	async _buildAssertion(payload) {
		const signingKey = await this._latestKey();

		if (null === signingKey
			|| 'object' !== typeof signingKey
			|| 'string' !== typeof signingKey.kid
			|| !SUPPORTED_ALGS.includes(signingKey.alg)
			|| 'object' !== typeof signingKey.key
		) {
			throw new Error('received invalid signing key from "keyLookup"');
		}

		payload = Object.assign({}, payload);

		payload.aud = ASSERTION_AUDIENCE;
		payload.iss = this._issuer;
		payload.iat = payload.nbf = this._clock();
		payload.exp = payload.iat + ASSERTION_LIFETIME_SECONDS;

		const assertion = await new jose.SignJWT(payload)
			.setProtectedHeader({
				alg: signingKey.alg,
				kid: signingKey.kid,
				typ: 'JWT',
				jti: uuid(),
			})
			.sign(signingKey.key);

		return assertion;
	}

	async _makeAssertion(assertion, scope) {
		const self = this;

		const res = await fetch(self._tokenEndpoint, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/x-www-form-urlencoded',
			},
			body: new URLSearchParams({
				assertion: assertion,
				grant_type: ASSERTION_GRANT_TYPE,
				scope: scope,
			}),
		});

		if (!res.ok) {
			throw new Error(`Request failed with status ${res.status}`);
		}

		const body = await res.json();

		return body.access_token;
	}

}

module.exports = AuthTokenProvisioner;
module.exports.AbstractProvisioningCache = AbstractProvisioningCache;
