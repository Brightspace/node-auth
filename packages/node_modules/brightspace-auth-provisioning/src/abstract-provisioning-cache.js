'use strict';

const qs = require('querystring');

const jws = require('jws');

const clock = require('./clock');

const DEFAULT_EXPIRY_SECONDS = 60 * 60;
const EXPIRY_BUFFER_TIME_SECONDS = 2 * 60;

class ValueLookupFailed extends Error {
	constructor(inner) {
		super('Value lookup failed');

		this.name = this.constructor.name;
		this.inner = inner;
	}
}

class AbstractProvisioningCache {

	async get(claims, scope) {
		if ('object' !== typeof claims) {
			throw new Error('"claims" must be an Object');
		}

		if ('string' !== typeof scope) {
			throw new Error('"scope" must be a String');
		}

		if ('function' !== typeof this._get) {
			throw new ValueLookupFailed();
		}

		const key = this._buildKey(claims, scope);

		let token;
		try {
			token = await this._get(key);
		} catch (e) {
			throw new ValueLookupFailed(e);
		}

		if ('string' !== typeof token) {
			throw new ValueLookupFailed();
		}

		const decodedToken = jws.decode(token);

		if ('object' !== typeof decodedToken
			|| 'object' !== typeof decodedToken.payload
			|| 'number' !== typeof decodedToken.payload.exp
			|| (decodedToken.payload.exp - EXPIRY_BUFFER_TIME_SECONDS) <= clock()
		) {
			throw new ValueLookupFailed();
		}

		return token;
	}

	async set(claims, scope, token) {
		if ('object' !== typeof claims) {
			throw new Error('"claims" must be an Object');
		}

		if ('string' !== typeof scope) {
			throw new Error('"scope" must be a String');
		}

		if ('string' !== typeof token) {
			throw new Error('"token" must be an encoded jwt');
		}

		const decodedToken = jws.decode(token);
		if ('object' !== typeof decodedToken || 'object' !== typeof decodedToken.payload) {
			throw new Error('"token" must be an encoded jwt');
		}

		if ('function' !== typeof this._set) {
			return;
		}

		const key = this._buildKey(claims, scope);

		let expiry = 'number' === typeof decodedToken.payload.exp
			? decodedToken.payload.exp
			: DEFAULT_EXPIRY_SECONDS + clock();
		expiry -= EXPIRY_BUFFER_TIME_SECONDS;

		await this._set(key, token, expiry);
	}

	_buildKey(claims, scope) {
		const request = Object.assign({}, claims);
		request.scope = scope;

		return qs.stringify(request);
	}

}

module.exports = AbstractProvisioningCache;
